# Pick an issue from GitHub and fix it with multi-backend consensus
#
# Usage:
#   lok run pick-and-fix
#
# This workflow:
# 1. Checks out main and pulls latest
# 2. Fetches open issues (excluding those with open PRs)
# 3. Has Claude pick the best one to fix
# 4. Gets fix proposals from multiple backends
# 5. Backends debate and converge on the best approach
# 6. Applies the consensus fix, verifies, commits, and creates a PR

name = "pick-and-fix"
description = "Pick the best open issue and fix it with multi-backend consensus"

[[steps]]
name = "setup"
shell = "git checkout main && git pull"

[[steps]]
name = "list"
depends_on = ["setup"]
shell = "gh issue list --limit 50 --json number,title,body,labels"

[[steps]]
name = "open_prs"
depends_on = ["setup"]
shell = "gh pr list --json number,title,body --jq '[.[] | {number, title, body}]'"

[[steps]]
name = "pick"
backend = "claude"
depends_on = ["list", "open_prs"]
prompt = """
Here are the open issues for this repo:

{{ steps.list.output }}

These PRs are already open (skip issues they reference):

{{ steps.open_prs.output }}

Pick the ONE issue that:
1. Does NOT already have an open PR (check PR titles/bodies for "Closes #N" or "issue N")
2. Has the highest priority label (P0 > P1 > P2 > P3 > unlabeled)
3. Is clearly defined (not vague or sprawling)
4. Can be fixed with a focused code change
5. Won't require major refactoring

PRIORITY ORDER: Always prefer P0 issues first, then P1, then P2, etc.
Look at the "labels" field in each issue - pick from highest priority that meets criteria.

Output JSON:
{
  "number": 123,
  "title": "issue title",
  "reason": "why this is the best pick"
}

Pick only ONE. Output only the JSON.
"""

[[steps]]
name = "fetch"
depends_on = ["pick"]
shell = "gh issue view {{ steps.pick.number }} --json body,comments"

[[steps]]
name = "propose_claude"
backend = "claude"
depends_on = ["fetch"]
prompt = """
Propose a fix for this issue:

Issue #{{ steps.pick.number }}: {{ steps.pick.title }}

Details:
{{ steps.fetch.output }}

Read the relevant code and propose the APPROACH to fix this.
Don't output JSON yet - just explain:
1. What's the root cause?
2. What files need to change?
3. What's your proposed fix?

Be specific but concise.
"""

[[steps]]
name = "propose_codex"
backend = "codex"
depends_on = ["fetch"]
prompt = """
Propose a fix for this issue:

Issue #{{ steps.pick.number }}: {{ steps.pick.title }}

Details:
{{ steps.fetch.output }}

Read the relevant code and propose the APPROACH to fix this.
Don't output JSON yet - just explain:
1. What's the root cause?
2. What files need to change?
3. What's your proposed fix?

Be specific but concise.
"""

[[steps]]
name = "propose_gemini"
backend = "gemini"
depends_on = ["fetch"]
prompt = """
Propose a fix for this issue:

Issue #{{ steps.pick.number }}: {{ steps.pick.title }}

Details:
{{ steps.fetch.output }}

Read the relevant code and propose the APPROACH to fix this.
Don't output JSON yet - just explain:
1. What's the root cause?
2. What files need to change?
3. What's your proposed fix?

Be specific but concise.
"""

[[steps]]
name = "debate"
backend = "claude"
depends_on = ["propose_claude", "propose_codex", "propose_gemini"]
prompt = """
Three AI backends proposed fixes for Issue #{{ steps.pick.number }}: {{ steps.pick.title }}

CLAUDE's proposal:
{{ steps.propose_claude.output }}

CODEX's proposal:
{{ steps.propose_codex.output }}

GEMINI's proposal:
{{ steps.propose_gemini.output }}

Analyze all three proposals:
1. What do they agree on?
2. Where do they differ?
3. Which approach is better and why?
4. What's the FINAL consensus approach?

Output a clear, specific plan for the fix that incorporates the best ideas from all three.
"""

[[steps]]
name = "fix"
backend = "codex"
depends_on = ["debate"]
apply_edits = true
verify = "true"
prompt = """
Implement the consensus fix for Issue #{{ steps.pick.number }}: {{ steps.pick.title }}

The debate concluded with this approach:
{{ steps.debate.output }}

Generate the code edits as JSON. Do NOT ask for permission or use any tools.
Your response must be ONLY a JSON object, nothing else.

{
  "edits": [{"file": "path/to/file.rs", "old": "exact text to replace", "new": "replacement text"}],
  "summary": "one-line description of the fix"
}

CRITICAL RULES:
- Output ONLY the JSON object above, no other text
- "old" must match the current file content EXACTLY (including whitespace)
- "file" paths are relative to repo root
- Keep edits minimal and focused
- Follow the consensus approach from the debate
"""

[[steps]]
name = "branch"
shell = "git checkout -b fix/issue-{{ steps.pick.number }}-$(date +%s)"
depends_on = ["fix"]

[[steps]]
name = "commit"
shell = """
git add -A && git commit -m "fix: {{ steps.fix.summary }}

Closes #{{ steps.pick.number }}"
"""
depends_on = ["branch"]

[[steps]]
name = "push"
shell = "git push -u origin HEAD"
depends_on = ["commit"]

[[steps]]
name = "pr"
shell = """
gh pr create \
  --title 'fix: {{ steps.fix.summary }}' \
  --body '## Issue
Closes #{{ steps.pick.number }}: {{ steps.pick.title }}

## Why this issue?
{{ steps.pick.reason }}

## Fix
{{ steps.fix.summary }}

This fix was developed through Claude + Codex consensus.

---
Automated fix by lok pick-and-fix workflow.'
"""
depends_on = ["push"]
