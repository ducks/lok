{
  "what": "Workflow: pick-and-fix",
  "why": "Pick the best open issue and fix it with multi-backend consensus",
  "how": "Steps:\n  ✓ setup (shell)\n  ✓ list (shell)\n  ✓ open_prs (shell)\n  ✓ pick (claude)\n  ✓ fetch (shell)\n  ✓ propose_gemini (gemini)\n  ✓ propose_codex (codex)\n  ✓ propose_claude (claude)\n  ✓ debate (claude)\n  ✓ fix (claude)\n  ✓ branch (shell)\n  ✓ commit (shell)\n  ✓ push (shell)\n  ✓ pr (shell)",
  "timestamp": "2026-02-02T21:32:14.357345040Z",
  "code_commit": "5a63d322856f2c37f446f7336f65158c988db4a8",
  "outcome": "success",
  "reasoning": "### propose_gemini\n\nI will start by reading `src/workflow.rs` around the mentioned lines to understand how workflows are currently loaded and where the validation should be added.\nI will search for the workflow loading or validation logic in `src/workflow.rs` to find the appropriate place for the fix.\nI will search for any validation logic or usage of `min_deps_success` in `src/workflow.rs` to pinpoint where the constraint should be checked.\nI will read `src/workflow.rs` around line 443 to see the runtime handling and look for any existing validation logic.\nI will search for a `validate` function in `src/workflow.rs` to see if there is an existing validation framework I should use.\nI will examine `load_workflow_from_source` in `src/workflow.rs` to see where the workflow is parsed and if there is a suitable place for adding validation.\nI will read `load_workflow_from_source_with_depth` in `src/workflow.rs` to see where the workflow content is parsed and validated.\nI will read `load_workflow_with_depth` in `src/workflow.rs` to see how it handles workflow loading and if there is a place for validation.\nI will read the `Workflow` and `Step` struct definitions in `src/workflow.rs` to understand their structure and where to add the validation method.\nI will read more of `src/workflow.rs` to locate the `Workflow` and `Step` struct definitions.\nI will search for the usage of `WorkflowError::MissingDependency` in `src/workflow.rs` to see where dependency validation is currently performed.\nI will read the context around line 1223 in `src/workflow.rs` to understand the existing dependency validation logic.\nI will read the lines preceding line 1201 in `src/workflow.rs` to identify the function containing the validation logic.\nI will search for the calls to `group_by_depth` in `src/workflow.rs` to see when this validation is triggered.\nI will search for the `impl Workflow` block in `src/workflow.rs` to see if there is an existing implementation where I can add a `validate` method.\nI will read `src/workflow.rs` around line 228 to see if there's any relevant code or if it's just the `Step` struct definition as I suspected.\nI will read the tests in `src/workflow.rs` to see how workflow loading and validation are currently tested.\nI will search for tests that involve workflow loading in `src/workflow.rs`.\nI will search for `toml::from_str` within the tests in `src/workflow.rs` to find how workflows are being parsed in tests.\nI will read the tests in `src/workflow.rs` around line 2721 to understand how `Step` parsing is tested.\nI will read `tests/integration.rs` to see if there are any integration tests that involve workflow loading and could be relevant for verifying the fix.\n### 1. Root Cause\nThe root cause is that the `Workflow` engine does not perform any validation on the `min_deps_success` field during the workflow loading phase. This allows a user to define a step where `min_deps_success` is greater than the total number of dependencies in `depends_on`. Since this condition can never be satisfied, the step will always fail at runtime with a potentially confusing error message, rather than being caught immediately when the workflow is loaded.\n\n### 2. Files to Change\n- `src/workflow.rs`: This file contains the `Workflow` and `Step` struct definitions, the `WorkflowError` enum, and the logic for loading and parsing workflows from TOML.\n\n### 3. Proposed Fix\nI will implement a validation step during the workflow loading process:\n\n1.  **Add a new error variant** to `WorkflowError`:\n    ```rust\n    #[error(\"Workflow '{workflow}': step '{step}' has min_deps_success ({min_deps_success}) exceeding number of dependencies ({actual_deps})\\n  hint: reduce min_deps_success or add more dependencies\")]\n    InvalidMinDeps {\n        workflow: String,\n        step: String,\n        min_deps_success: usize,\n        actual_deps: usize,\n    },\n    ```\n\n2.  **Add a `validate` method** to the `Workflow` struct that iterates through all steps and ensures `min_deps_success <= depends_on.len()` for each step.\n\n3.  **Update the public loading functions** `load_workflow` and `load_workflow_from_source` in `src/workflow.rs` to call `workflow.validate()?` after the workflow (including any inherited steps from `extends`) has been fully loaded and merged.\n\n4.  **Add a unit test** in `src/workflow.rs` to verify that a workflow with an invalid `min_deps_success` value fails validation with the expected error.\n\n### propose_codex\n\nRoot cause  \n- `min_deps_success` is only evaluated during execution (in the consensus check in `WorkflowRunner::run`). There’s no validation when the workflow is parsed/merged, so a value greater than `depends_on.len()` isn’t rejected early and only fails at runtime with a generic “consensus not reached” message.\n\nFiles to change  \n- `src/workflow.rs` (add load-time validation; likely add a new `WorkflowError` variant)  \n- Optionally tests in `src/workflow.rs` (or `tests/`) to cover invalid `min_deps_success`\n\nProposed fix  \n- Add a validation pass right after workflow parsing/merging (in `load_workflow_with_depth` and `load_workflow_from_source_with_depth`, after `merge_workflows` is applied).  \n- Implement a helper like `validate_workflow(&Workflow) -> Result<()>` that iterates steps and checks:  \n  - if `min_deps_success` is `Some(n)` and `n > step.depends_on.len()`, return a clear error:  \n    `Workflow '{name}': step '{step}' min_deps_success (5) cannot exceed number of dependencies (3)`  \n  - (Optional but sensible) also error if `depends_on.is_empty()` and `min_deps_success` is set to a nonzero value.  \n- Add a `WorkflowError::InvalidMinDepsSuccess { workflow, step, min, deps }` to keep errors consistent with existing load-time validation.  \n- Add a unit test that builds a workflow with `min_deps_success` > `depends_on.len()` and asserts load fails with the new error.\n\n### propose_claude\n\nGood. Now I understand the issue completely.\n\n## Analysis\n\n### 1. Root Cause\n\nThe `min_deps_success` field is only validated at **runtime** (line 455-461 in `workflow.rs`) when checking if enough dependencies succeeded. If someone sets `min_deps_success = 5` but only has 3 dependencies, the step will always fail with \"Consensus not reached: 0/3 dependencies succeeded (need 5)\" or similar. This is confusing because the constraint is impossible to satisfy.\n\n### 2. Files to Change\n\nOnly **`src/workflow.rs`** needs to change.\n\n### 3. Proposed Fix\n\nAdd validation during workflow loading, right after the workflow is parsed (in both `load_workflow_with_depth` and `load_workflow_from_source_with_depth`). The validation should:\n\n1. Iterate through each step\n2. If `min_deps_success` is `Some(n)`, check that `n <= step.depends_on.len()`\n3. If invalid, return an error like: `\"Step 'step_name': min_deps_success (5) cannot exceed number of dependencies (3)\"`\n\nThe cleanest approach is to add a `validate_workflow(workflow: &Workflow) -> Result<()>` helper function that's called after parsing in both loading paths. This keeps the validation logic in one place and can be extended for other validations later.\n\nThe validation should happen **after** inheritance merging (if `extends` is used), since the child workflow might override dependencies or min_deps_success values.\n\n### debate\n\n## Analysis of the Three Proposals\n\n### 1. What They Agree On\n\nAll three backends converge on the same core approach:\n\n- **Root cause**: `min_deps_success` is only validated at runtime, not at load time\n- **File to change**: `src/workflow.rs` is the only file that needs modification\n- **Solution pattern**: Add a `validate_workflow()` or `workflow.validate()` helper that checks `min_deps_success <= depends_on.len()`\n- **Validation timing**: After workflow parsing/merging (so inherited steps are included)\n- **Error message format**: Include workflow name, step name, the invalid value, and actual dependency count\n- **Add tests**: Unit test for the new validation\n\n### 2. Where They Differ\n\n| Aspect | Claude | Codex | Gemini |\n|--------|--------|-------|--------|\n| **Function style** | Standalone `validate_workflow(workflow: &Workflow)` | Standalone helper | Method on `Workflow` struct |\n| **Error variant name** | Not specified | `InvalidMinDepsSuccess` | `InvalidMinDeps` |\n| **Extra validation** | None mentioned | Also error if `depends_on.is_empty()` with nonzero `min_deps_success` | None mentioned |\n| **Error hint** | None | None | Includes hint: \"reduce min_deps_success or add more dependencies\" |\n\n### 3. Which Approach is Better\n\n**Gemini's method-on-struct approach** is cleaner for Rust idioms. Having `workflow.validate()` keeps validation close to the data structure and makes it easier to extend later.\n\n**Codex's extra validation** (error when `depends_on.is_empty()` but `min_deps_success > 0`) catches another impossible condition. This is worth including.\n\n**Gemini's hint in the error** is helpful for users who hit this error.\n\n**Codex's error variant name** (`InvalidMinDepsSuccess`) is more specific than Gemini's (`InvalidMinDeps`), making it clearer what's wrong.\n\n### 4. FINAL Consensus Approach\n\n**Add a `validate()` method to the `Workflow` struct that:**\n\n1. Iterates through all steps\n2. For each step with `min_deps_success = Some(n)`:\n   - Error if `n > step.depends_on.len()`\n   - Error if `n > 0` and `step.depends_on.is_empty()` (Codex's suggestion)\n3. Returns `Result<(), WorkflowError>`\n\n**New error variant:**\n```rust\n#[error(\"Workflow '{workflow}': step '{step}' min_deps_success ({min_deps_success}) exceeds number of dependencies ({actual_deps})\\n  hint: reduce min_deps_success or add more dependencies\")]\nInvalidMinDepsSuccess {\n    workflow: String,\n    step: String,\n    min_deps_success: usize,\n    actual_deps: usize,\n},\n```\n\n**Call validation from:**\n- `load_workflow_with_depth()` after `merge_workflows()` completes\n- `load_workflow_from_source_with_depth()` after `merge_workflows()` completes\n\n**Add unit test:**\n- Create workflow with `min_deps_success = 5` and only 3 dependencies\n- Assert load fails with `InvalidMinDepsSuccess` error\n- Test the edge case: `min_deps_success = 1` with empty `depends_on`\n\n---\n\n## Implementation Plan\n\n1. **Add error variant** to `WorkflowError` enum in `src/workflow.rs`\n\n2. **Add `validate()` method** to `impl Workflow`:\n   ```rust\n   pub fn validate(&self) -> Result<(), WorkflowError> {\n       for step in &self.steps {\n           if let Some(min) = step.min_deps_success {\n               let deps_count = step.depends_on.len();\n               if min > deps_count {\n                   return Err(WorkflowError::InvalidMinDepsSuccess {\n                       workflow: self.name.clone(),\n                       step: step.name.clone(),\n                       min_deps_success: min,\n                       actual_deps: deps_count,\n                   });\n               }\n           }\n       }\n       Ok(())\n   }\n   ```\n\n3. **Call `workflow.validate()?`** after merge in both loading functions\n\n4. **Add tests** for both the normal case and the empty-depends-on edge case\n\n### fix\n\nNow I have all the information I need. Let me implement the fix:\n\n**Intent:**\n- **what**: Add `InvalidMinDepsSuccess` error variant to `WorkflowError`, add `validate()` method to `Workflow`, call validation in both loading functions\n- **how**: Edit `src/workflow.rs` in 4 places: add error variant, add impl block with validate(), call validate in both load functions, add tests\n- **backup**: If edit patterns don't match, re-read the specific sections and retry with exact text\n\n```json\n{\n  \"action\": \"fix\",\n  \"what\": \"Add load-time validation for min_deps_success configuration\",\n  \"why\": \"Prevents invalid workflow configs where min_deps_success > number of dependencies, catching errors early with helpful messages\",\n  \"edits\": [\n    {\n      \"file\": \"src/workflow.rs\",\n      \"old\": \"    #[error(\\\"Workflow '{workflow}': duplicate step names: {}\\\\n  hint: each step must have a unique name\\\", duplicates.join(\\\", \\\"))]\\n    DuplicateStepNames {\\n        workflow: String,\\n        duplicates: Vec<String>,\\n    },\\n}\",\n      \"new\": \"    #[error(\\\"Workflow '{workflow}': duplicate step names: {}\\\\n  hint: each step must have a unique name\\\", duplicates.join(\\\", \\\"))]\\n    DuplicateStepNames {\\n        workflow: String,\\n        duplicates: Vec<String>,\\n    },\\n\\n    #[error(\\\"Workflow '{workflow}': step '{step}' has min_deps_success ({min_deps_success}) exceeding number of dependencies ({actual_deps})\\\\n  hint: reduce min_deps_success or add more dependencies\\\")]\\n    InvalidMinDepsSuccess {\\n        workflow: String,\\n        step: String,\\n        min_deps_success: usize,\\n        actual_deps: usize,\\n    },\\n}\"\n    },\n    {\n      \"file\": \"src/workflow.rs\",\n      \"old\": \"/// A single step in a workflow\\n#[derive(Debug, Deserialize, Serialize, Clone)]\\npub struct Step {\",\n      \"new\": \"impl Workflow {\\n    /// Validate workflow configuration at load time\\n    pub fn validate(&self) -> Result<(), WorkflowError> {\\n        for step in &self.steps {\\n            if let Some(min) = step.min_deps_success {\\n                let deps_count = step.depends_on.len();\\n                if min > deps_count {\\n                    return Err(WorkflowError::InvalidMinDepsSuccess {\\n                        workflow: self.name.clone(),\\n                        step: step.name.clone(),\\n                        min_deps_success: min,\\n                        actual_deps: deps_count,\\n                    });\\n                }\\n            }\\n        }\\n        Ok(())\\n    }\\n}\\n\\n/// A single step in a workflow\\n#[derive(Debug, Deserialize, Serialize, Clone)]\\npub struct Step {\"\n    },\n    {\n      \"file\": \"src/workflow.rs\",\n      \"old\": \"        let parent = Box::pin(load_workflow_from_source_with_depth(\\n            parent_source,\\n            depth + 1,\\n        ))\\n        .await?;\\n        workflow = merge_workflows(parent, workflow);\\n    }\\n\\n    Ok(workflow)\\n}\\n\\n/// Load a workflow from its source with depth tracking for extends\\nasync fn load_workflow_from_source_with_depth(\",\n      \"new\": \"        let parent = Box::pin(load_workflow_from_source_with_depth(\\n            parent_source,\\n            depth + 1,\\n        ))\\n        .await?;\\n        workflow = merge_workflows(parent, workflow);\\n    }\\n\\n    workflow.validate()?;\\n    Ok(workflow)\\n}\\n\\n/// Load a workflow from its source with depth tracking for extends\\nasync fn load_workflow_from_source_with_depth(\"\n    },\n    {\n      \"file\": \"src/workflow.rs\",\n      \"old\": \"                let parent = Box::pin(load_workflow_from_source_with_depth(\\n                    parent_source,\\n                    depth + 1,\\n                ))\\n                .await?;\\n                workflow = merge_workflows(parent, workflow);\\n            }\\n\\n            Ok(workflow)\\n        }\\n    }\\n}\\n\\n/// Merge parent workflow with child workflow\",\n      \"new\": \"                let parent = Box::pin(load_workflow_from_source_with_depth(\\n                    parent_source,\\n                    depth + 1,\\n                ))\\n                .await?;\\n                workflow = merge_workflows(parent, workflow);\\n            }\\n\\n            workflow.validate()?;\\n            Ok(workflow)\\n        }\\n    }\\n}\\n\\n/// Merge parent workflow with child workflow\"\n    },\n    {\n      \"file\": \"src/workflow.rs\",\n      \"old\": \"        let step: Step = toml::from_str(toml_str).unwrap();\\n        assert!(!step.continue_on_error);\\n    }\\n}\",\n      \"new\": \"        let step: Step = toml::from_str(toml_str).unwrap();\\n        assert!(!step.continue_on_error);\\n    }\\n\\n    #[tokio::test]\\n    async fn test_min_deps_success_validation_exceeds_deps() {\\n        let dir = tempdir().unwrap();\\n        let workflow_path = dir.path().join(\\\"test.toml\\\");\\n        std::fs::write(\\n            &workflow_path,\\n            r#\\\"\\nname = \\\"test-workflow\\\"\\n\\n[[steps]]\\nname = \\\"step1\\\"\\nbackend = \\\"claude\\\"\\nprompt = \\\"first\\\"\\n\\n[[steps]]\\nname = \\\"step2\\\"\\nbackend = \\\"claude\\\"\\nprompt = \\\"second\\\"\\n\\n[[steps]]\\nname = \\\"step3\\\"\\nbackend = \\\"claude\\\"\\nprompt = \\\"synthesize\\\"\\ndepends_on = [\\\"step1\\\", \\\"step2\\\"]\\nmin_deps_success = 5\\n\\\"#,\\n        )\\n        .unwrap();\\n\\n        let result = load_workflow(&workflow_path).await;\\n        assert!(result.is_err());\\n        let err = result.unwrap_err().to_string();\\n        assert!(err.contains(\\\"min_deps_success (5) exceeding number of dependencies (2)\\\"));\\n        assert!(err.contains(\\\"step3\\\"));\\n    }\\n\\n    #[tokio::test]\\n    async fn test_min_deps_success_validation_empty_deps() {\\n        let dir = tempdir().unwrap();\\n        let workflow_path = dir.path().join(\\\"test.toml\\\");\\n        std::fs::write(\\n            &workflow_path,\\n            r#\\\"\\nname = \\\"test-workflow\\\"\\n\\n[[steps]]\\nname = \\\"step1\\\"\\nbackend = \\\"claude\\\"\\nprompt = \\\"run this\\\"\\nmin_deps_success = 1\\n\\\"#,\\n        )\\n        .unwrap();\\n\\n        let result = load_workflow(&workflow_path).await;\\n        assert!(result.is_err());\\n        let err = result.unwrap_err().to_string();\\n        assert!(err.contains(\\\"min_deps_success (1) exceeding number of dependencies (0)\\\"));\\n    }\\n\\n    #[tokio::test]\\n    async fn test_min_deps_success_validation_valid() {\\n        let dir = tempdir().unwrap();\\n        let workflow_path = dir.path().join(\\\"test.toml\\\");\\n        std::fs::write(\\n            &workflow_path,\\n            r#\\\"\\nname = \\\"test-workflow\\\"\\n\\n[[steps]]\\nname = \\\"step1\\\"\\nbackend = \\\"claude\\\"\\nprompt = \\\"first\\\"\\n\\n[[steps]]\\nname = \\\"step2\\\"\\nbackend = \\\"claude\\\"\\nprompt = \\\"second\\\"\\n\\n[[steps]]\\nname = \\\"step3\\\"\\nbackend = \\\"claude\\\"\\nprompt = \\\"synthesize\\\"\\ndepends_on = [\\\"step1\\\", \\\"step2\\\"]\\nmin_deps_success = 2\\n\\\"#,\\n        )\\n        .unwrap();\\n\\n        let result = load_workflow(&workflow_path).await;\\n        assert!(result.is_ok());\\n    }\\n}\"\n    }\n  ],\n  \"summary\": \"Add load-time validation that min_deps_success <= depends_on.len() with helpful error messages\"\n}\n```"
}